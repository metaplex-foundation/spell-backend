use entities::l2::{AssetSorting, L2Asset, PublicKey};
use serde::{Deserialize, Serialize};
use solana_sdk::transaction::Transaction;
use thiserror::Error;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct L2AssetInfo {
    pub asset: L2Asset,
    pub metadata: Option<String>,
}

#[async_trait::async_trait]
pub trait AssetService {
    /// Create a new L2 asset and set given authority pubkey as the created asset authority.
    ///
    /// The sequence of action in the flow is following:
    /// 1) Persists the binary asset in our storage
    /// 2) Persist the NFT metadata json in our storage
    /// 3) Generate a public key derived from our keypair and use it as asset ID
    /// 4) Create a record about L2 asset in our storage
    ///
    /// The owner and creator of all L2 assets is "we", i.e. HD key derived from our mnemonic.
    /// Returns a pubkey of the newly created asset.
    ///
    /// ## Args:
    /// * `metadata_json` - NTF metadata file generated by client
    /// * `owner` -
    /// * `creator` -
    /// * `authority` - pubkey of a user who is generationg the asset
    /// * `name` - NFT asset name
    /// * `royalty_basis_points` - royalty basis points of asset which will be used for minting it on L1.
    ///     It represents a `%` so it cant be less than `0` and more than `10_000`
    /// * `collection` - a collection the asset belongs to
    async fn create_asset(
        &self,
        metadata_json: &str,
        owner: PublicKey,
        creator: PublicKey,
        authority: PublicKey,
        name: &str,
        royalty_basis_points: u16,
        collection: Option<PublicKey>,
    ) -> anyhow::Result<L2AssetInfo>;

    /// Updates existing L2 asset.
    async fn update_asset(
        &self,
        asset_pubkey: PublicKey,
        metadata_json: Option<&str>,
        owner: Option<PublicKey>,
        creator: Option<PublicKey>,
        authority: Option<PublicKey>,
        name: Option<&str>,
        collection: Option<Option<PublicKey>>,
    ) -> anyhow::Result<Option<L2AssetInfo>>;

    /// Fetches existing L2 asset.
    ///
    /// ## Args:
    /// * `asset_pubkey` - public key that has been generate on L2 asset creation
    async fn fetch_asset(&self, asset_pubkey: PublicKey) -> anyhow::Result<Option<L2AssetInfo>>;

    /// Fetches existing L2 assets.
    ///
    /// ## Args:
    /// * `asset_pubkeys` - public keys that has been generate on L2 asset creation
    async fn fetch_assets(&self, asset_pubkeys: &[PublicKey]) -> anyhow::Result<Vec<L2AssetInfo>>;

    /// Fetch NFT metadata JSON for given asset
    async fn fetch_metadata(&self, asset_pubkey: PublicKey) -> anyhow::Result<Option<String>>;

    /// Fetches existing L2 assets by owner.
    /// This specification was used for implementation:
    ///
    /// https://docs.extrnode.com/das_api/get_assets_by_owner
    ///
    /// ## Args:
    /// * `owner_pubkey` - public key of asset owner
    /// * `sorting` - sorting params for response
    /// * `limit` - limit of returning assets
    async fn fetch_assets_by_owner(
        &self,
        owner_pubkey: PublicKey,
        sorting: &AssetSorting,
        limit: u32,
        before: Option<&str>,
        after: Option<&str>,
    ) -> anyhow::Result<Vec<L2AssetInfo>>;

    async fn fetch_assets_by_creator(
        &self,
        creator_pubkey: PublicKey,
        sorting: &AssetSorting,
        limit: u32,
        before: Option<&str>,
        after: Option<&str>,
    ) -> anyhow::Result<Vec<L2AssetInfo>>;

    /// Execute asset L1 mint transaction received from the client.
    async fn execute_asset_l1_mint(&self, tx: Transaction) -> anyhow::Result<()>;
}

#[derive(Error, Debug)]
pub enum L1MintError {
    #[error("Either locked or already minted")]
    NotUnlockedL2Asset,
    #[error("Wrong asset name, expected='{0}', actual='{1}'")]
    WrongName(String, String),
    #[error("Wrong metadata URI")]
    WrongMetadataUri,
    #[error("Missing authority")]
    MissingAuthority,
    #[error("Wrong authority")]
    WrongAuthority,
    #[error("Missing owner")]
    MissingOwner,
    #[error("Wrong owner")]
    WrongOwner,
    #[error("Wrong collection")]
    WrongCollection,
}
