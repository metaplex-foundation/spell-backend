use entities::l2::{AssetSorting, L2Asset, PublicKey};
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct L2AssetInfo {
    pub asset: L2Asset,
    pub metadata: Option<String>,
}

#[async_trait::async_trait]
pub trait AssetService {
    /// Create a new L2 asset and set given authority pubkey as the created asset authority.
    ///
    /// The sequence of action in the flow is following:
    /// 1) Persists the binary asset in our storage
    /// 2) Persist the NFT metadata json in our storage
    /// 3) Generate a public key derived from our keypair and use it as asset ID
    /// 4) Create a record about L2 asset in our storage
    ///
    /// The owner and creator of all L2 assets is "we", i.e. HD key derived from our mnemonic.
    /// Returns a pubkey of the newly created asset.
    ///
    /// ## Args:
    /// * `metadata_json` - NTF metadata file generated by client
    /// * `owner` -
    /// * `creator` -
    /// * `authority` - pubkey of a user who is generationg the asset
    /// * `name` - NFT asset name
    /// * `collection` - a collection the asset belongs to
    async fn create_asset(
        &self,
        metadata_json: &str,
        owner: PublicKey,
        creator: PublicKey,
        authority: PublicKey,
        name: &str,
        collection: Option<PublicKey>,
    ) -> anyhow::Result<L2AssetInfo>;

    /// Updates existing L2 asset.
    async fn update_asset(
        &self,
        asset_pubkey: PublicKey,
        metadata_json: Option<&str>,
        owner: Option<PublicKey>,
        creator: Option<PublicKey>,
        authority: Option<PublicKey>,
        name: Option<&str>,
        collection: Option<Option<PublicKey>>,
    ) -> anyhow::Result<Option<L2AssetInfo>>;

    /// Fetches existing L2 asset.
    ///
    /// ## Args:
    /// * `asset_pubkey` - public key that has been generate on L2 asset creation
    async fn fetch_asset(&self, asset_pubkey: PublicKey) -> anyhow::Result<Option<L2AssetInfo>>;

    /// Fetches existing L2 assets.
    ///
    /// ## Args:
    /// * `asset_pubkeys` - public keys that has been generate on L2 asset creation
    async fn fetch_assets(&self, asset_pubkeys: &[PublicKey]) -> anyhow::Result<Vec<L2AssetInfo>>;

    /// Fetch NFT metadata JSON for given asset
    async fn fetch_metadata(&self, asset_pubkey: PublicKey) -> anyhow::Result<Option<String>>;

    /// Fetches existing L2 assets by owner.
    /// This specification was used for implementation:
    ///
    /// https://docs.extrnode.com/das_api/get_assets_by_owner
    ///
    /// ## Args:
    /// * `owner_pubkey` - public key of asset owner
    /// * `sorting` - sorting params for response
    /// * `limit` - limit of returning assets
    async fn fetch_assets_by_owner(
        &self,
        owner_pubkey: PublicKey,
        sorting: &AssetSorting,
        limit: u32,
        before: Option<&String>,
        after: Option<&String>,
    ) -> anyhow::Result<Vec<L2AssetInfo>>;
}
